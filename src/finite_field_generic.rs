#![allow(dead_code)]

use num_traits::FromPrimitive;
use std::ops::{Add, Div, Mul, Rem, Sub};

pub trait FiniteField:
    Copy
    + Clone
    + Eq
    + PartialEq
    + PartialOrd
    + Add<Output = Self>
    + Mul<Output = Self>
    + Sub<Output = Self>
    + Div<Output = Self>
    + Rem<Output = Self>
    + FromPrimitive
{
}

impl FiniteField for u32 {}
impl FiniteField for u64 {}
impl FiniteField for u128 {}
impl FiniteField for i32 {}
impl FiniteField for i64 {}
impl FiniteField for i128 {}

// impl FiniteField for FieldElement<i32> {}

#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct FieldElement<T>
where
    T: FiniteField,
{
    num: T,
    prime: T,
}

impl<T: FiniteField> FieldElement<T> {
    pub fn new(num: T, prime: T) -> Result<Self, &'static str> {
        if prime <= T::from_i32(1).unwrap() {
            return Err("Prime must be greater than 1");
        }

        if num >= prime {
            return Err("Number must be in range [0, prime - 1]");
        }

        Ok(FieldElement { num, prime })
    }

    pub fn pow(self, exponent: T) -> Self {
        if exponent == T::from_i32(0).unwrap() {
            return Self::new(T::from_i32(1).unwrap(), self.prime).unwrap();
        }

        let mut n = exponent;
        let mut base = self;
        let mut result = Self::new(T::from_i32(1).unwrap(), self.prime).unwrap();

        while n > T::from_i32(0).unwrap() {
            if n % T::from_i32(2).unwrap() == T::from_i32(1).unwrap() {
                result = result * base;
            }
            n = n / T::from_i32(2).unwrap();
            base = base * base;
        }

        result
    }
}

impl<T: FiniteField> Add for FieldElement<T> {
    type Output = Self;
    fn add(self, other: Self) -> Self {
        assert!(self.prime == other.prime);
        let num = (self.num + other.num) % self.prime;
        Self::new(num, self.prime).unwrap()
    }
}

impl<T: FiniteField> Sub for FieldElement<T> {
    type Output = Self;
    fn sub(self, other: Self) -> Self {
        assert!(self.prime == other.prime);
        let num = (self.num + self.prime - other.num) % self.prime;
        Self::new(num, self.prime).unwrap()
    }
}

impl<T: FiniteField> Mul for FieldElement<T> {
    type Output = Self;
    fn mul(self, other: Self) -> Self {
        assert!(self.prime == other.prime);
        let num = (self.num * other.num) % self.prime;
        Self::new(num, self.prime).unwrap()
    }
}

impl<T: FiniteField> Div for FieldElement<T> {
    type Output = Self;
    fn div(self, other: Self) -> Self {
        assert!(self.prime == other.prime);
        let res = self * other.pow(self.prime - T::from_i32(2).unwrap());
        Self::new(res.num, self.prime).unwrap()
    }
}

impl<T: FiniteField> Rem for FieldElement<T> {
    type Output = Self;

    fn rem(self, rhs: Self) -> Self::Output {
        Self::new(self.num % rhs.num, self.prime).unwrap()
    }
}

impl<T: FiniteField> PartialOrd for FieldElement<T> {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        if self.prime != other.prime {
            None
        } else {
            self.num.partial_cmp(&other.num)
        }
    }
}

// This was generated by Copilot. I have no idea about this.
impl<T: FiniteField> FromPrimitive for FieldElement<T> {
    fn from_i8(_n: i8) -> Option<Self> {
        None
    }

    fn from_i16(_n: i16) -> Option<Self> {
        None
    }

    fn from_i32(_n: i32) -> Option<Self> {
        None
    }

    fn from_i64(_n: i64) -> Option<Self> {
        None
    }

    fn from_i128(_n: i128) -> Option<Self> {
        None
    }

    fn from_u8(_n: u8) -> Option<Self> {
        None
    }

    fn from_u16(_n: u16) -> Option<Self> {
        None
    }

    fn from_u32(_n: u32) -> Option<Self> {
        None
    }

    fn from_u64(_n: u64) -> Option<Self> {
        None
    }

    fn from_u128(_n: u128) -> Option<Self> {
        None
    }

    fn from_f32(_n: f32) -> Option<Self> {
        None
    }

    fn from_f64(_n: f64) -> Option<Self> {
        None
    }
}

impl FiniteField for FieldElement<u32> {}
impl FiniteField for FieldElement<u64> {}
impl FiniteField for FieldElement<u128> {}
impl FiniteField for FieldElement<i32> {}
impl FiniteField for FieldElement<i64> {}
impl FiniteField for FieldElement<i128> {}

#[cfg(test)]
mod tests {
    use super::*;

    type FeU32 = FieldElement<u32>;

    #[test]
    fn test_field_element_creation() {
        let fe = FieldElement::new(7u32, 13u32);
        assert!(fe.is_ok());
        let fe = fe.unwrap();
        assert_eq!(fe.num, 7);
        assert_eq!(fe.prime, 13);
    }

    #[test]
    fn test_field_element_addition() {
        let fe1 = FieldElement::new(7u32, 13u32).unwrap();
        let fe2 = FieldElement::new(12u32, 13u32).unwrap();
        let result = fe1 + fe2;
        assert_eq!(result.num, 6);
        assert_eq!(result.prime, 13);
    }

    #[test]
    fn test_field_element_substraction() {
        let fe1 = FieldElement::new(6u32, 19u32).unwrap();
        let fe2 = FieldElement::new(13u32, 19u32).unwrap();
        let result = fe1 - fe2;
        assert_eq!(result.num, 12);
        assert_eq!(result.prime, 19);
    }

    #[test]
    fn test_field_element_mul() {
        let a = FieldElement::<u32>::new(3, 13).unwrap();
        let b = FieldElement::<u32>::new(12, 13).unwrap();
        let result = FieldElement::<u32>::new(10, 13).unwrap();

        assert_eq!(result, a * b);
        assert_eq!(result, b * a);
    }

    #[test]
    fn test_field_element_pow() {
        let a = FeU32::new(3, 13).unwrap();
        let result = FeU32::new(1, 13).unwrap();
        let zero = FeU32::new(0, 13).unwrap();
        let one = FeU32::new(1, 13).unwrap();

        // 3**3 = 27%13 = 1
        assert_eq!(result, a.pow(3));
        // 3**0 = 1
        assert_eq!(one, a.pow(0));
        // 3**1 = 3
        assert_eq!(a, a.pow(1));
        // 0**0 = 1
        assert_eq!(one, zero.pow(0));
    }

    #[test]
    fn test_field_element_div() {
        let a = FeU32::new(2, 19).unwrap();
        let b = FeU32::new(7, 19).unwrap();
        let result = FeU32::new(3, 19).unwrap();
        // 2/7 = ( 2*7^17 ) % 19 = 3
        assert_eq!(result, a / b);

        let a = FeU32::new(7, 19).unwrap();
        let b = FeU32::new(5, 19).unwrap();
        let result = FeU32::new(9, 19).unwrap();
        // 7/5 = ( 7*5^17 ) % 19 = 9
        assert_eq!(result, a / b);
    }
}
